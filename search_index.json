[["index.html", "Debugging in practice 1 About this course 1.1 Requirements", " Debugging in practice Simo Tuomisto 2022-04-25 1 About this course This course is a part of How to debug code-course by Aalto Scientific Computing. The course structure and some of the material is adapted from the Python part of the debugging course. Most of the R material is constructed from various books and blog posts available online. Reading this material for more in-depth explanation of concepts shown in this course is highly recommended. Advanced R by Hadley Wickham1 especially cannot be recommended enough. 1.1 Requirements This course utilizes RStudio IDE as it provides easy access for many debugging tools. sloop-package2 is used to check some R object features: install.packages(&quot;sloop&quot;) Hadley Wickham, Advanced r (CRC press, 2019), https://adv-r.hadley.nz.↩︎ Hadley Wickham, Sloop: Helpers for OOP in r, 2019, https://CRAN.R-project.org/package=sloop.↩︎ "],["whatis.html", "2 What is debugging 2.1 The four steps of debugging 2.2 Debugging is the art of identifying inconsistency between the expected and actual operation", " 2 What is debugging 2.1 The four steps of debugging Identify the bug Get a report from user or find an example input that exhibits the problem Find the faulty line or piece of logic Isolate Confirm that you have found the problem Could be e.g. a unit test or a minimal (non)working example Fix Replacing the erroneous code with correct code Test Check that the bug is fixed and no new bugs were introduced. In this course we are concentrating on the identifying phase. It is expected, that as soon as you identify the bug, it is more or less obvious how it should be fixed. 2.2 Debugging is the art of identifying inconsistency between the expected and actual operation A problem exists whenever the user expects the system to operate differently from how it actually operates. The issue may lay either in the expectations or in the system. Sometimes a program does do what the programmer intents it to do, but the user expects some other behaviour. Then the bug is in the user interface (UI), in the application programming interface (API) or in the documentation. For scientific computation this is most often encountered when starting to use a new library or software. However, we concentrate on the common and basic problem of how to fix your own code. Here the inconsistency is usually between what you mean the computer to do and what you tell the computer to do. The key to success is to have sufficiently deep understanding of what your code and the programming language does, to simulate in your mind the program. This is all just a complicated way to say, that to debug R successfully, you need to know the R language and some details of the underlying runtime. Thus, we first recapitulate a few key features of the R language. We say a few words on how to avoid problems. After that we take a look at the R specific tools to help analyze a R program. "],["features.html", "3 R features relevant for debugging 3.1 Interpreter 3.2 Functions 3.3 Objects 3.4 Libraries", " 3 R features relevant for debugging 3.1 Interpreter R is an interpreted language, which means that code is interpreted by the R interpreter during runtime. This has the effect that syntax errors occur only when the code is run. Thus using an IDE like Rstudio makes coding easier as it notifies the user on such errors beforehand. When R exists it also can save the current environment (aka. workspace) into a .RData-file. One should be careful to make certain that existing workspace does not interfere with the code. For non-interactive usage one usually uses Rscript or R CMD BATCH. Rscript is usually better. However, when interpreter is launched using Rscript, the list of default packages is minimal: Rscript --help ## Usage: /path/to/Rscript [--options] [-e expr [-e expr2 ...] | file] [args] ## ## --options accepted are ## --help Print usage and exit ## --version Print version and exit ## --verbose Print information on progress ## --default-packages=list ## Where &#39;list&#39; is a comma-separated set ## of package names, or &#39;NULL&#39; ## or options to R, in addition to --slave --no-restore, such as ## --save Do save workspace at the end of the session ## --no-environ Don&#39;t read the site and user environment files ## --no-site-file Don&#39;t read the site-wide Rprofile ## --no-init-file Don&#39;t read the user R profile ## --restore Do restore previously saved objects at startup ## --vanilla Combine --no-save, --no-restore, --no-site-file ## --no-init-file and --no-environ ## ## &#39;file&#39; may contain spaces but not shell metacharacters ## Expressions (one or more &#39;-e &lt;expr&gt;&#39;) may be used *instead* of &#39;file&#39; ## See also ?Rscript from within R 3.2 Functions 3.2.1 R is a functional language R is at its core a functional language. This means that coding is often done in terms of functions that operate on objects and which return a new object. These function calls are then often chained together and vectorized with apply-family of functions. For more info, see this chapter of Advanced R. 3.2.2 Lazy evaluation R uses lazy evaluation when functions are called. This means that functions are evaluated only when the output is actually used. In the following example the value of g(x) is not evaluated for positive values and thus the undefined variable is not encountered until f(x) is called with a negative value: g &lt;- function(x) { return(x + z) } f &lt;- function(x,y = g(x)) { if (x&gt;0) { return(x) } else { return(y) } } f(1) ## [1] 1 f(-1) ## Error in g(x): object &#39;z&#39; not found Lazy evaluation can make it easy to miss bugs in alternative execution paths. See this r-bloggers’ post for more information on lazy evaluation. 3.2.3 R functions are evaluated in an environment Each R function has an environment that houses known names to values (e.g. function names, variables etc.). The global environment is the top level environment that contains everything done by the user. Function calls etc. get their own environment that inherit their parent’s environment. When running R code interactively the global environment can often become filled with various variables and definitions. Thus it is a good idea to clean up the environment every now and then and verify that your code works from a clean slate. Thus one can easily run into situations such as this: f(-2) ## Error in g(x): object &#39;z&#39; not found z &lt;- 2 f(-2) ## [1] 0 Objects can also write to their parents’ environment using the &lt;&lt;--operator: h &lt;- function(x) { x &lt;&lt;- x } x &lt;- 1 x ## [1] 1 h(2) x ## [1] 2 This can obviously cause problems and should be avoided in most cases. For more info, see this chapter of Advanced R. 3.3 Objects 3.3.1 All objects in R have a base type There are 25 base types in R such as integer, double, list and closure (function). One can check the type using typeof(x)-function. a &lt;- 1:10 b &lt;- list(a=1:10) c &lt;- data.frame(b) typeof(a) ## [1] &quot;integer&quot; typeof(b) ## [1] &quot;list&quot; typeof(c) ## [1] &quot;list&quot; typeof(f) ## [1] &quot;closure&quot; R is strongly, but dynamically typed. This means that objects have to keep their type, but objects can be cast to new types automatically. As an example, consider the following function that does a simple division: d &lt;- function(x,y) { print(is.integer(x)) print(is.integer(y)) print(is.integer(x/y)) return(x/y) } d(10,3) ## [1] FALSE ## [1] FALSE ## [1] FALSE ## [1] 3.333333 d(10L,3L) ## [1] TRUE ## [1] TRUE ## [1] FALSE ## [1] 3.333333 For more info, see this chapter of Advanced R. 3.3.2 Vectors are everywhere and they are immutable R is a heavily vectorized language. Most mathematical operations in R are sped up by doing them to the vector as a whole. You can think of vectors as a collection of a thing with a length. There are two types of vectors in R: atomic vectors and list vectors. Atomic vectors are your typical logical, numeric (integer or double) and character vectors. x_vector &lt;- 1:6 is.atomic(x_vector) ## [1] TRUE Each vector has a type and a length: typeof(x_vector) ## [1] &quot;integer&quot; length(x_vector) ## [1] 6 Lists are vectors that can contain other vectors. They are not atomic. Elements in a list can have names. x_list &lt;- list(x_vector=x_vector) x_list ## $x_vector ## [1] 1 2 3 4 5 6 names(x_list) ## [1] &quot;x_vector&quot; is.vector(x_list) ## [1] TRUE is.atomic(x_list) ## [1] FALSE Whenever you modify objects R will copy the data to a new location: x_vector2 &lt;- x_vector tracemem(x_vector) == tracemem(x_vector2) ## [1] TRUE x_vector2 &lt;- x_vector2 + 1 tracemem(x_vector) == tracemem(x_vector2) ## [1] FALSE However, when you modify lists, only the list changes, but not the atomics it points to. This makes it excellent for storing data: x_list2 &lt;- x_list tracemem(x_list) == tracemem(x_list2) ## [1] TRUE x_list2$x_vector2 &lt;- x_vector2 ## tracemem[0x55675af9f0b8 -&gt; 0x55675b6f7870]: eval eval eval_with_user_handlers withVisible withCallingHandlers handle timing_fn evaluate_call &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group.block process_group withCallingHandlers process_file &lt;Anonymous&gt; &lt;Anonymous&gt; render_cur_session &lt;Anonymous&gt; tracemem(x_list) == tracemem(x_list2) ## [1] FALSE tracemem(x_list$x_vector) == tracemem(x_list2$x_vector) ## [1] TRUE Most R objects are built on top of vectors or lists by giving them attributes. When they get attributes, they cease to be pure vectors. print(x_vector) ## [1] 1 2 3 4 5 6 print(attributes(x_vector)) ## NULL print(is.vector(x_vector)) ## [1] TRUE x_array &lt;- array(x_vector, dim=c(3,2)) print(x_array) ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 print(attributes(x_array)) ## $dim ## [1] 3 2 print(is.vector(x_array)) ## [1] FALSE data.frame is an extremely important object in R built on top of a list. It has an additional constraints added to it: All vectors in a data frame need to have the same length. It has rownames() and colnames(). names() of the data frame are the column names. A data frame has nrow() rows and ncol() columns. The length() of a data frame gives the number of columns. tibble is a modern drop-in replacement for data.frame that is highly recommended for its usability. For more information on tibbles, see the packages web page.3 data.table is another popular alternative for data.frame. It has its own usability enhancements and it scales better for big data than a normal data frame. For more information on data.table, see the packages web page.4 For more info on vectors, lists and data frames, see this chapter of Advanced R. 3.3.3 Base types are extended using object-oriented (OO) programming Examples in this section utilize the sloop-package5 for finding more information on objects. You can install it with: install.packages(&quot;sloop&quot;) In R nomenclature, everything is an object. But not everything is an OO-style object. OO-objects have a class-attribute. One can also use is.object()-function to check whether the object is an OO object and sloop::s3_class() to get the class in a reliable way: a &lt;- 1:10 b &lt;- list(a=1:10) c &lt;- data.frame(b) attr(a, &quot;class&quot;) ## NULL attr(b, &quot;class&quot;) ## NULL attr(c, &quot;class&quot;) ## [1] &quot;data.frame&quot; is.object(a) ## [1] FALSE is.object(b) ## [1] FALSE is.object(c) ## [1] TRUE sloop::s3_class(a) ## [1] &quot;integer&quot; &quot;numeric&quot; sloop::s3_class(b) ## [1] &quot;list&quot; sloop::s3_class(c) ## [1] &quot;data.frame&quot; One can strip the object back to its base types with unclass()-function: unclass(c) ## $a ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## attr(,&quot;row.names&quot;) ## [1] 1 2 3 4 5 6 7 8 9 10 There are multiple OO paradigms in R: - S3: Oldest and simplest system. Most of R OO-objects are S3 objects. - S4: More advanced version of S3. Heavily used by the Bioconductor-project. - R6: More like other OO languages. Improved version on R’s feature called reference classes. See R6 manual for more information6. 3.3.4 Method dispatch Most R functions are S3 generic functions that choose between available methods for a class. One can check whether a function is a generic function or a method with sloop::ftype(). For example, paste() is an internal method that works with types, but print() is an S3 generic: sloop::ftype(paste) ## [1] &quot;internal&quot; sloop::ftype(print) ## [1] &quot;S3&quot; &quot;generic&quot; To see which function is used for a given object, one can use sloop::s3_dispatch(): sloop::s3_dispatch(print(c)) ## =&gt; print.data.frame ## * print.default Now one can check the difference between these methods: sloop::ftype(print.data.frame) ## [1] &quot;S3&quot; &quot;method&quot; sloop::ftype(print.default) ## [1] &quot;internal&quot; print.data.frame(c) ## a ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 ## 6 6 ## 7 7 ## 8 8 ## 9 9 ## 10 10 print.default(c) ## $a ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## attr(,&quot;class&quot;) ## [1] &quot;data.frame&quot; Knowing about method dispatch is especially important when dealing with numerical data. Numeric can mean that something is a double or that something behaves like a number (integer and double). Typically everything in R is stored as doubles. x_i &lt;- 1L x_n &lt;- 1 is.integer(x_i) ## [1] TRUE is.numeric(x_i) ## [1] TRUE is.integer(x_n) ## [1] FALSE is.numeric(x_n) ## [1] TRUE Another problem that can happen is that one can easily remove the class functionality from an S3 object. Let’s consider a simple linear model. After fitting a linear model, one might try to store the coefficients into a variable: x &lt;- 1:10 err &lt;- rnorm(10, 0, 0.5) y &lt;- 10 * x - 10 + err d &lt;- data.frame(x=x, y=y) my_model &lt;- lm(y ~ x, data=d) my_coefs &lt;- my_model$coefficients my_coefs ## (Intercept) x ## -9.670400 9.988736 After this, one might do a predictive fit: y_pred &lt;- my_coefs[2] * x + my_coefs[1] y_pred ## [1] 0.3183355 10.3070713 20.2958072 30.2845430 40.2732788 50.2620146 ## [7] 60.2507504 70.2394863 80.2282221 90.2169579 However, coefficients do not contain all of the information that the model has. Instead of ripping the coefficients out from the object, one should utilize the S3 generic function predict for models that support it. This will allow the model to stay as an S3 object: attributes(my_model) ## $names ## [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; ## [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; ## [9] &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; &quot;model&quot; ## ## $class ## [1] &quot;lm&quot; sloop::ftype(predict) ## [1] &quot;S3&quot; &quot;generic&quot; predict(my_model) ## 1 2 3 4 5 6 7 ## 0.3183355 10.3070713 20.2958072 30.2845430 40.2732788 50.2620146 60.2507504 ## 8 9 10 ## 70.2394863 80.2282221 90.2169579 Utilizing these generic functions gives R great power, as one can use similar coding structures for various different models. For example, predict can operate on multiple different models with corresponding methods: methods(predict) ## [1] predict.ar* predict.Arima* ## [3] predict.arima0* predict.glm ## [5] predict.HoltWinters* predict.lm ## [7] predict.loess* predict.mlm* ## [9] predict.nls* predict.poly* ## [11] predict.ppr* predict.prcomp* ## [13] predict.princomp* predict.smooth.spline* ## [15] predict.smooth.spline.fit* predict.StructTS* ## see &#39;?methods&#39; for accessing help and source code 3.4 Libraries 3.4.1 Libraries are usually compiled R libraries can be pure R or they can utilize other languages. Many R’s internal functions utilize R’s API for writing extensions. Common used languages are C, C++ and Fortran. Reason for this is speed provided by these lower level languages. However, this API can be very complicated and thus most new packages use C/C++ with Rcpp-package.7 This means that during installation many R libraries need C and C++ compilers and external libraries, which can result in various errors if you lack said requirements. Debugging Rcpp-code requires one to utilize C/C++ debuggers. For more information one can look for example at this blog post.8 For more information on Rcpp, one can check Rcpp for everyone9, this chapter in Advanced R R-tibble?↩︎ R-data.table?↩︎ Wickham, Sloop.↩︎ Winston Chang, R6: Encapsulated Classes with Reference Semantics, 2022.↩︎ R-Rcpp?↩︎ Davis Vaughan, “Debugging an r Package with c++,” 2017, https://blog.davisvaughan.com/2019/04/05/debug-r-package-with-cpp/.↩︎ Masaki E. Tsuda, Rcpp for Everyone, 2020, https://teuder.github.io/rcpp4everyone_en/.↩︎ "],["practice.html", "4 Debugging R code 4.1 Tracing errors 4.2 Interactive debugger 4.3 Launching browser in code 4.4 Setting breakpoint in editor 4.5 Launching debugger with recover() 4.6 More tools 4.7 Exercise: k-means clustering", " 4 Debugging R code This chapter follows the excellent debugging-chapter from Advanced R10. 4.1 Tracing errors 4.1.1 Traceback Let’s consider the previously showed function example with a missing variable: # Ensure that z is missing if (exists(&quot;z&quot;)) { rm(z) } g &lt;- function(x) { return(x + z) } f &lt;- function(x,y = g(x)) { if (x&gt;0) { return(x) } else { return(y) } } f(-1) ## Error in g(x): object &#39;z&#39; not found This example is available here: missing-variables.R. Opening the file with RStudio and sourcing the file will return the following kind of an error: Now clicking the Show traceback-button will expand the traceback: This view will quickly show that the error comes from the g(x)-function call in line #13. Sometimes lazy evaluation can make reading the call stack complicated. Let’s have a few additional functions that are called in the argument definition: i &lt;- function() { return(z) } h &lt;- function() { return(i()) } f(x=-1, y=h()) ## Error in i(): object &#39;z&#39; not found Error is raised by i(), but looking at the call stack it almost looks like f() is somehow involved. This is because value of h() is evaluated only when it is needed in f(). Writing the code like this would reveal the true culprit: h_value=h() ## Error in i(): object &#39;z&#39; not found f(x=-1, y=h_value) ## Error in f(x = -1, y = h_value): object &#39;h_value&#39; not found Of course, this is not something you want to do generally. Lazy evaluation is good for speeding up your code, so doing changes like this should be limited to situations where you’re unsure which function causes the error. 4.1.2 Traceback outside of RStudio editor If you run the code in R console in RStudio or in a separate interpreter you might not get the Show Traceback-prompt. In those situations you can use the traceback()-function to get the trace. You can try it out with the following test in the console: f(-1) traceback() You can also set the R error handling to call traceback on errors: backup_options &lt;- options() options(error=traceback) f(-1) options(backup_options) Here we also took a backup of the default options. This is usually a good idea as changing options will change the options for the whole R session. 4.2 Interactive debugger 4.2.1 Launching debugger with RStudio’s “Rerun with Debug” RStudio can launch you a debugger at the location where the error occured. If you source the file again and launch the debugger with Rerun with Debug, you’ll get an interactive debugger that looks something like this: This view has many areas of interest: On the top left RStudio will open the source code of the problematic function and it tries to highlight the line that causes the error. On the top right we have an environment browser that shows what variables are defined inside the g()-function’s environment. On the bottom right we have the traceback of the erroneous function call. The function we’re investigating is highlighted. On the bottom left we have the interactive debugger open in the console. 4.2.2 Debugger commands The interactive debugger console has multiple commands (more info available here): Continue, c or cont: Exit the browser and continue execution at the next statement. Finish, f: Finish execution of the current loop or function Help, help: Print this list of commands Next, n : Evaluate the next statement, stepping over function calls. For byte compiled functions interrupted by browser calls, n is equivalent to c. Step, s: Evaluate the next statement, stepping into function calls. Again, byte compiled functions make s equivalent to c. Where, where: Print a stack trace of all active function calls. Resume, r: Invoke a “resume” restart if one is available; interpreted as an R expression otherwise. Typically “resume” restarts are established for continuing from user interrupts. Quit, Q: Exit the browser and the current evaluation and return to the top-level prompt. RStudio also has a toolbar in debugger console with buttons for next (n), step (s), finish (f), continue (c) and stop (Q). Figure 4.1: RStudio debugger toolbar. Source: Advanced R In addition to these commands one can run arbitrary R-commands to list variables, test their values etc. 4.2.3 debug and debugonce You can also launch debugger from the console with debug()- and debugonce()-functions. debug(f) will set a permanent flag that will cause a debugger to be launched whenever function f is called. You can unset this variable with undebug. Alternatively, you can use debugonce to launch the debugger once for a function. This is especially useful if the function you want to debug is inside a for-loop. You can try this with the following: debugonce(g) f(-1) 4.3 Launching browser in code One can also launch the interactive browser by specifying browser() is the code: g_browse &lt;- function(x) { browser() return(x + z) } f(-1, y=g_browse(x)) This is very useful when you’re writing new code and you want to check what the function does line-by-line. 4.4 Setting breakpoint in editor In RStudio editor you can also set a temporary breakpoint by clicking to the left of the line number. This will put a red dot next to the line number. This is a break point which will acts like a browser()-call. Setting breakpoints is even faster way of debugging code while you’re developing it. 4.5 Launching debugger with recover() You can also launch the debugger when an error occurs by setting the error option to use recover(): option(error=recover) f(-1) options(backup_options) Again, we’ll want to restore the previous settings once we’re finished. You can also set a similar behaviour in RStudio by checking Debug -&gt; On Error -&gt; Break in Code from the top menu. RStudio will try to limit the debugger launching to functions that are written by you. In some cases, e.g. if you give wrong arguments to a packaged function, this will result in a situation where you do not get a debugger when you want it. To bypass RStudio’s check, you’ll need to uncheck Use debug error handler only when my code contains errors in Tools -&gt; Global Options -&gt; General. 4.6 More tools There are plenty of more tools like trace, utils::setBreakpoint() etc. See debugging-chapter from Advanced R11 for more information on these. 4.7 Exercise: k-means clustering Let’s try out interactive debugging with a simple machine learning problem: using k-means clustering on the famous iris-dataset. In this exercise there are four bugs hidden in the code. Try to use debugging tools to spot them out. The bugs should appear in order, so if you fix one, you can continue to the next. This example is available here: exercise-k-means.R. Hints for each of the problems are available here: exercise-k-means-hints.txt. Solution is available here: exercise-k-means-solution.R. normalize_standard &lt;- function(dataset) { # Normalizes each column in the dataset to standard normalization # https://en.wikipedia.org/wiki/Standard_score normalized_data &lt;- data.frame() for (column in colnames(dataset)) { data_mean &lt;- mean(dataset[[column]]) data_sd &lt;- sd(dataset[column]) normalized_data[[column]] &lt;- ((dataset[[column]] - data_mean))/data_sd } return(normalized_data) } kmeans_iris &lt;- function() { # Load data data(iris) # Rename iris to some other variable iris_data &lt;- iris # Normalize data iris_normalized &lt;- normalize_standard(iris_data) # Take species out species &lt;- iris_data$Species iris_data$Species &lt;- NULL # Calculate kmeans clustering # https://en.wikipedia.org/wiki/K-means_clustering clustering &lt;- kmeans(iris_normalized, 3) # Calculate confusion matrix # https://en.wikipedia.org/wiki/Confusion_matrix#Confusion_matrices_with_more_than_two_categories table(species, clustering$clusters) } print(kmeans_iris()) ## Error in is.data.frame(x): (list) object cannot be coerced to type &#39;double&#39; Wickham, Advanced r.↩︎ Wickham.↩︎ "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
