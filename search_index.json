[["index.html", "R features relevant for debugging 1 About this course 1.1 Requirements 1.2 Building the materials", " R features relevant for debugging Simo Tuomisto 2022-04-24 1 About this course This course is a part of How to debug code-course by Aalto Scientific Computing. 1.1 Requirements For this course one needs RStudio IDE. 1.2 Building the materials One can clone the git repository and build the materials. git clone https://github.com/AaltoSciComp/r-debugging cd r-debugging conda env create -f environment.yml After this one needs to install bookdown1 and render the materials: install.packages(&quot;bookdown&quot;) rmarkdown::render_site(output_format = &#39;bookdown::gitbook&#39;, encoding = &#39;UTF-8&#39;) Rendering might require texlive to be installed as well. Yihui Xie, Bookdown: Authoring Books and Technical Documents with r Markdown, 2022, https://CRAN.R-project.org/package=bookdown.↩︎ "],["intro.html", "2 Introduction 2.1 The four steps of debugging 2.2 Debugging is the art of identifying inconsistency between the expected and actual operation", " 2 Introduction The course structure and some of the material is adapted from the Python part of the debugging course. Most of the R material is constructed from various books and blog posts available online. Reading this material for more in-depth explanation of concepts shown in this course is highly recommended. 2.1 The four steps of debugging Identify the bug Get a report from user or find an example input that exhibits the problem Find the faulty line or piece of logic Isolate Confirm that you have found the problem Could be e.g. a unit test or a minimal (non)working example Fix Replacing the erroneous code with correct code Test Check that the bug is fixed and no new bugs were introduced. In this course we are concentrating on the identifying phase. It is expected, that as soon as you identify the bug, it is more or less obvious how it should be fixed. 2.2 Debugging is the art of identifying inconsistency between the expected and actual operation A problem exists whenever the user expects the system to operate differently from how it actually operates. The issue may lay either in the expectations or in the system. Sometimes a program does do what the programmer intents it to do, but the user expects some other behaviour. Then the bug is in the user interface (UI), in the application programming interface (API) or in the documentation. For scientific computation this is most often encountered when starting to use a new library or software. However, we concentrate on the common and basic problem of how to fix your own code. Here the inconsistency is usually between what you mean the computer to do and what you tell the computer to do. The key to success is to have sufficiently deep understanding of what your code and the programming language does, to simulate in your mind the program. This is all just a complicated way to say, that to debug R successfully, you need to know the R language and some details of the underlying runtime. Thus, we first recapitulate a few key features of the R language. We say a few words on how to avoid problems. After that we take a look at the R specific tools to help analyze a R program. "],["r-features-relevant-for-debugging.html", "3 R features relevant for debugging 3.1 Interpreter 3.2 Functions 3.3 Objects 3.4 Libraries", " 3 R features relevant for debugging 3.1 Interpreter R is an interpreted language, which means that code is interpreted by the R interpreter during runtime. This has the effect that syntax errors occur only when the code is run. Thus using an IDE like Rstudio makes coding easier as it notifies the user on such errors beforehand. When R exists it also can save the current environment (aka. workspace) into a .RData-file. One should be careful to make certain that existing workspace does not interfere with the code. For non-interactive usage one usually uses Rscript or R CMD BATCH. Rscript is usually better. However, when interpreter is launched using Rscript, the list of default packages is minimal: Rscript --help ## Usage: /path/to/Rscript [--options] [-e expr [-e expr2 ...] | file] [args] ## ## --options accepted are ## --help Print usage and exit ## --version Print version and exit ## --verbose Print information on progress ## --default-packages=list ## Where &#39;list&#39; is a comma-separated set ## of package names, or &#39;NULL&#39; ## or options to R, in addition to --no-echo --no-restore, such as ## --save Do save workspace at the end of the session ## --no-environ Don&#39;t read the site and user environment files ## --no-site-file Don&#39;t read the site-wide Rprofile ## --no-init-file Don&#39;t read the user R profile ## --restore Do restore previously saved objects at startup ## --vanilla Combine --no-save, --no-restore, --no-site-file ## --no-init-file and --no-environ ## ## &#39;file&#39; may contain spaces but not shell metacharacters ## Expressions (one or more &#39;-e &lt;expr&gt;&#39;) may be used *instead* of &#39;file&#39; ## See also ?Rscript from within R 3.2 Functions 3.2.1 R is a functional language R is at its core a functional language. This means that coding is often done in terms of functions that operate on objects and which return a new object. These function calls are then often chained together and vectorized with apply-family of functions. On one hand testing individual smaller functions can be easy, but on the other hand the function call stacks can get quite deep. For more info, see this chapter of Advanced R. 3.2.2 Lazy evaluation R uses lazy evaluation when functions are called. This means that functions are evaluated only when the output is actually used. In the following example the value of g(x) is not evaluated for positive values and thus the undefined variable is not encountered until f(x) is called with a negative value:: g &lt;- function(x) { return(x + z) } f &lt;- function(x,y = g(x)) { if (x&gt;0) { return(x) } else { return(g(x)) } } f(1) ## [1] 1 f(-1) ## Error in g(x): object &#39;z&#39; not found Lazy evaluation can make it easy to miss bugs in alternative execution paths. See this r-bloggers’ post for more information on lazy evaluation. 3.2.3 R functions are evaluated in an environment Each R function has an environment that houses known names to values (e.g. function names, variables etc.). The global environment is the top level environment that contains everything done by the user. Function calls etc. get their own environment that inherit their parent’s environment. Thus one can easily run into situations such as this: f(-2) ## Error in g(x): object &#39;z&#39; not found z &lt;- 2 f(-2) ## [1] 0 Objects can also write to their parents’ environment: h &lt;- function(x) { x &lt;&lt;- x } x &lt;- 1 x ## [1] 1 h(2) x ## [1] 2 This can obviously cause problems and should be avoided in most cases. For more info, see this chapter of Advanced R. 3.3 Objects 3.3.1 All objects in R have a base type There are 25 base types in R such as integer, double, list and closure (function). One can check the type using typeof(x)-function. a &lt;- 1:10 b &lt;- list(a=1:10) c &lt;- data.frame(b) typeof(a) ## [1] &quot;integer&quot; typeof(b) ## [1] &quot;list&quot; typeof(c) ## [1] &quot;list&quot; typeof(f) ## [1] &quot;closure&quot; R is strongly, but dynamically typed. This means that objects have to keep their type, but objects can be cast to new types automatically. As an example, consider the following function that does a simple division: d &lt;- function(x,y) { print(is.integer(x)) print(is.integer(y)) print(is.integer(x/y)) return(x/y) } d(10,3) ## [1] FALSE ## [1] FALSE ## [1] FALSE ## [1] 3.333333 d(10L,3L) ## [1] TRUE ## [1] TRUE ## [1] FALSE ## [1] 3.333333 For more info, see this chapter of Advanced R. 3.3.2 Base types are extended using object-oriented (OO) programming Examples in this section utilize the sloop2-package. For finding more information on objects. You can install it with: install.packages(&quot;sloop&quot;) In R nomenclature, everything is an object. But not everything is an OO-style object. OO-objects have a class-attribute. One can also use is.object()-function to check whether the object is an OO object and sloop::s3_class to get the class in a reliable way: attr(a, &quot;class&quot;) ## NULL attr(b, &quot;class&quot;) ## NULL attr(c, &quot;class&quot;) ## [1] &quot;data.frame&quot; is.object(a) ## [1] FALSE is.object(b) ## [1] FALSE is.object(c) ## [1] TRUE sloop::s3_class(a) ## [1] &quot;integer&quot; &quot;numeric&quot; sloop::s3_class(b) ## [1] &quot;list&quot; sloop::s3_class(c) ## [1] &quot;data.frame&quot; One can strip the object back to its base types with unclass()-function: unclass(c) ## $a ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## attr(,&quot;row.names&quot;) ## [1] 1 2 3 4 5 6 7 8 9 10 There are multiple OO paradigms in R: S3: Oldest and simplest system. Most of R OO-objects are S3 objects. S4: More advanced version of S3. Heavily used by the Bioconductor-project. R6: More like other OO languages. Improved version on R’s feature called reference classes. See R6 manual for more information3. 3.3.3 Method dispatch Most R functions are S3 generic functions that choose between available methods for a class. One can check whether a function is a generic function or a method with sloop::ftype(). For example, paste is an internal method that works with types, but print is an S3 generic: sloop::ftype(paste) ## [1] &quot;internal&quot; sloop::ftype(print) ## [1] &quot;S3&quot; &quot;generic&quot; To see which function is used for a given object, one can use sloop::s3_dispatch(): sloop::s3_dispatch(print(c)) ## =&gt; print.data.frame ## * print.default Now one can check the difference between these methods: sloop::ftype(print.data.frame) ## [1] &quot;S3&quot; &quot;method&quot; sloop::ftype(print.default) ## [1] &quot;internal&quot; print.data.frame(c) ## a ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 ## 6 6 ## 7 7 ## 8 8 ## 9 9 ## 10 10 print.default(c) ## $a ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## attr(,&quot;class&quot;) ## [1] &quot;data.frame&quot; Knowing about method dispatch is especially important when dealing with numerical data. Numeric can mean that something is a double or that something behaves like a number (integer and double). Typically everything in R is stored as doubles. x_i &lt;- 1L x_n &lt;- 1 is.integer(x_i) ## [1] TRUE is.numeric(x_i) ## [1] TRUE is.integer(x_n) ## [1] FALSE is.numeric(x_n) ## [1] TRUE Another problem that can happen is that one can easily remove the class functionality from an S3 object. Let’s consider a simple linear model. After fitting a linear model, one might try to store the coefficients into a variable: x &lt;- 1:10 err &lt;- rnorm(10, 0, 0.5) y &lt;- 10 * x - 10 + err d &lt;- data.frame(x=x, y=y) my_model &lt;- lm(y ~ x, data=d) my_coefs &lt;- my_model$coefficients my_coefs ## (Intercept) x ## -10.14417 10.04615 After this, one might do a predictive fit: y_pred &lt;- my_coefs[2] * x + my_coefs[1] y_pred ## [1] -0.09802368 9.94812190 19.99426747 30.04041305 40.08655863 50.13270421 ## [7] 60.17884979 70.22499536 80.27114094 90.31728652 However, coefficients do not contain all of the information that the model has. Instead of ripping the coefficients out from the object, one should utilize the S3 generic function predict for models that support it. This will allow the model to stay as an S3 object: attributes(my_model) ## $names ## [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; ## [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; ## [9] &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; &quot;model&quot; ## ## $class ## [1] &quot;lm&quot; sloop::ftype(predict) ## [1] &quot;S3&quot; &quot;generic&quot; predict(my_model) ## 1 2 3 4 5 6 ## -0.09802368 9.94812190 19.99426747 30.04041305 40.08655863 50.13270421 ## 7 8 9 10 ## 60.17884979 70.22499536 80.27114094 90.31728652 Utilizing these generic functions gives R great power, as one can use similar coding structures for various different models. For example, predict can operate on multiple different models with corresponding methods: methods(predict) ## [1] predict.ar* predict.Arima* ## [3] predict.arima0* predict.glm ## [5] predict.HoltWinters* predict.lm ## [7] predict.loess* predict.mlm* ## [9] predict.nls* predict.poly* ## [11] predict.ppr* predict.prcomp* ## [13] predict.princomp* predict.smooth.spline* ## [15] predict.smooth.spline.fit* predict.StructTS* ## see &#39;?methods&#39; for accessing help and source code 3.4 Libraries 3.4.1 Libraries are usually compiled R libraries can be pure R or they can utilize other languages. Many R’s internal functions utilize R’s API for writing extensions. Common used languages are C, C++ and Fortran. Reason for this is speed provided by these lower level languages. However, this API can be very complicated and thus most new packages use C/C++ with Rcpp-package.4 This means that during installation many R libraries need C/C++ compiler and external libraries, which can result in various errors. Debugging Rcpp-code requires one to utilize C/C++ debuggers. For more information one can look for example at this blog post.5 For more information on Rcpp, one can check Rcpp for everyone6, this chapter in Advanced R Hadley Wickham, Sloop: Helpers for OOP in r, 2019, https://CRAN.R-project.org/package=sloop.↩︎ Winston Chang, R6: Encapsulated Classes with Reference Semantics, 2022.↩︎ R-Rcpp?↩︎ Davis Vaughan, “Debugging an r Package with c++,” 2017, https://blog.davisvaughan.com/2019/04/05/debug-r-package-with-cpp/.↩︎ Masaki E. Tsuda, Rcpp for Everyone, 2020, https://teuder.github.io/rcpp4everyone_en/.↩︎ "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
