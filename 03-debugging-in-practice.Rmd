---
title: "Debugging R"
output:
  html_document:
    df_print: paged
---

# Debugging R code {#practice}

This chapter follows the excellent [debugging-chapter from Advanced R](https://adv-r.hadley.nz/debugging.html)[@wickham2019advanced].

## Tracing errors

### Traceback

Let's consider the previously showed function example with a missing variable:

```{r, collapse=TRUE, error=TRUE}
# Ensure that z is missing
if (exists("z")) {
  rm(z)
}
g <- function(x) {
  return(x + z)
}

f <- function(x,y = g(x)) {
  if (x>0) {
    return(x)
  } else {
    return(y)
  }
}
f(-1)
```
This example is available here: [missing-variables.R](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/examples/missing-variables.R).

Opening the file with RStudio and sourcing the file will return the following kind of an error:

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables.png)

Now clicking the **Show traceback**-button will expand the traceback:

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables-traceback.png)

This view will quickly show that the error comes from the `g(x)`-function call in line #13. 

Sometimes lazy evaluation can make reading the call stack complicated.
Let's have a few additional functions that are called in the argument definition:

```{r, collapse=TRUE, error=TRUE}
i <- function() {
  return(z)
}
h <- function() {
  return(i())
}
f(x=-1, y=h())
```

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables-lazy-evaluation.png)

Error is raised by `i()`, but looking at the call stack it almost looks like `f()` is somehow involved. This is because value of `h()` is evaluated only when it is needed in `f()`. Writing the code like this would reveal the true culprit:
```{r, collapse=TRUE, error=TRUE}
h_value=h()
f(x=-1, y=h_value)
```

Of course, this is not something you want to do generally. Lazy evaluation is good for speeding up your code, so doing changes like this should be limited to situations where you're unsure which function causes the error.

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables-nonlazy-evaluation.png)


### Traceback outside of RStudio editor

If you run the code in R console in RStudio or in a separate interpreter you might not get the **Show Traceback**-prompt.
In those situations you can use the `traceback()`-function to get the trace. You can try it out with the following test in the console:
```{r, eval=FALSE}
f(-1)
traceback()
```
You can also set the R error handling to call traceback on errors:
```{r, eval=FALSE}
backup_options <- options()
options(error=traceback)
f(-1)
options(backup_options)
```
Here we also took a backup of the default options. This is usually a good idea as changing options will change the options for the whole R session. 

## Interactive debugger

### Launching debugger with RStudio's "Rerun with Debug"

RStudio can launch you a debugger at the location where the error occured. If you source the file again and launch the debugger with **Rerun with Debug**, you'll get an interactive debugger that looks something like this:

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables-run-with-debug.png)

This view has many areas of interest:

- On the top left RStudio will open the source code of the problematic function
  and it tries to highlight the line that causes the error.
- On the top right we have an environment browser that shows what variables are defined inside
  the `g()`-function's environment.
- On the bottom right we have the traceback of the erroneous function call.
  The function we're investigating is highlighted.
- On the bottom left we have the interactive debugger open in the console.

### Debugger commands

The interactive debugger console has multiple commands (more info available [here](https://rdrr.io/r/base/browser.html)):

- Continue, `c` or `cont`: Exit the browser and continue execution at the next statement.
- Finish, `f`: Finish execution of the current loop or function
- Help, `help`: Print this list of commands
- Next, `n` : Evaluate the next statement, stepping over function calls. For byte compiled functions interrupted by browser calls, n is equivalent to c.
- Step, `s`: Evaluate the next statement, stepping into function calls. Again, byte compiled functions make s equivalent to c.
- Where, `where`: Print a stack trace of all active function calls.
- Resume,  `r`: Invoke a "resume" restart if one is available; interpreted as an R expression otherwise. Typically "resume" restarts are established for continuing from user interrupts.
- Quit, `Q`: Exit the browser and the current evaluation and return to the top-level prompt.

RStudio also has a toolbar in debugger console with buttons for next (`n`), step (`s`), finish (`f`), continue (`c`) and stop (`Q`).

```{r, fig.cap="RStudio debugger toolbar. Source: Advanced R", out.width='70%', echo=FALSE}
knitr::include_graphics('https://github.com/hadley/adv-r/raw/master/screenshots/debug-toolbar.png')
```

In addition to these commands one can run arbitrary R-commands to list variables, test their values etc.

### `debug` and `debugonce`

You can also launch debugger from the console with `debug()`- and `debugonce()`-functions.

`debug(f)` will set a permanent flag that will cause a debugger to be launched whenever
function `f` is called. You can unset this variable with `undebug`.

Alternatively, you can use `debugonce` to launch the debugger once for a function. This is
especially useful if the function you want to debug is inside a for-loop. You can try this with the following:

```{r, eval=FALSE}
debugonce(g)
f(-1)
```

## Launching browser in code

One can also launch the interactive browser by specifying `browser()` is the code:
```{r, eval=FALSE}
g_browse <- function(x) {
  browser()
  return(x + z)
}
f(-1, y=g_browse(x))
```

This is very useful when you're writing new code and you want to check what the function does line-by-line.

## Setting breakpoint in editor

In RStudio editor you can also set a temporary breakpoint by clicking to the left of the line number.
This will put a red dot next to the line number. This is a break point which will acts like a `browser()`-call.

Setting breakpoints is even faster way of debugging code while you're developing it.

## Launching debugger with `recover()`

You can also launch the debugger when an error occurs by setting the error option to use `recover()`:
```{r, eval=FALSE}
option(error=recover)
f(-1)
options(backup_options)
```
Again, we'll want to restore the previous settings once we're finished.

You can also set a similar behaviour in RStudio by checking
**Debug** -> **On Error** -> **Break in Code** from the top menu.

RStudio will try to limit the debugger launching to functions that are written by you.
In some cases, e.g. if you give wrong arguments to a packaged function, this will result in a situation where
you do not get a debugger when you want it. To bypass RStudio's check, you'll need to
uncheck *Use debug error handler only when my code contains errors* in
**Tools** -> **Global Options** -> **General**.

## More tools

There are plenty of more tools like `trace`, `utils::setBreakpoint()` etc. See [debugging-chapter from Advanced R](https://adv-r.hadley.nz/debugging.html)[@wickham2019advanced] for more information on these.

## Exercise: k-means clustering

Let's try out interactive debugging with a simple machine learning problem: using k-means clustering on the famous iris-dataset.

In this exercise there are four bugs hidden in the code. Try to use debugging tools to spot them out.
The bugs should appear in order, so if you fix one, you can continue to the next. 

This example is available here: [exercise-k-means.R](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/examples/exercise-k-means.R).
Hints for each of the problems are available here:
[exercise-k-means-hints.txt](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/examples/exercise-k-means-hints.txt).
Solution is available here:
[exercise-k-means-solution.R](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/examples/exercise-k-means.R).

```{r, collapse=TRUE, error=TRUE}

normalize_standard <- function(dataset) {
  # Normalizes each column in the dataset to standard normalization
  # https://en.wikipedia.org/wiki/Standard_score
  normalized_data <- data.frame()
  for (column in colnames(dataset)) {
    data_mean <- mean(dataset[[column]])
    data_sd <- sd(dataset[column])
    normalized_data[[column]] <- ((dataset[[column]] - data_mean))/data_sd
  }
  return(normalized_data)
}

kmeans_iris <- function() {
  # Load data
  data(iris)
  
  # Rename iris to some other variable
  iris_data <- iris
  
  # Normalize data
  iris_normalized <- normalize_standard(iris_data)
  
  # Take species out
  species <- iris_data$Species
  iris_data$Species <- NULL
  
  # Calculate kmeans clustering
  # https://en.wikipedia.org/wiki/K-means_clustering
  clustering <- kmeans(iris_normalized, 3)
  
  # Calculate confusion matrix
  # https://en.wikipedia.org/wiki/Confusion_matrix#Confusion_matrices_with_more_than_two_categories
  table(species, clustering$clusters)
}

print(kmeans_iris())
```

