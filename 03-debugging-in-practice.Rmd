---
title: "Debugging R"
output:
  html_document:
    df_print: paged
---

# Debugging R code {#practice}

This chapter follows the excellent [debugging-chapter from Advanced R](https://adv-r.hadley.nz/debugging.html)[@wickham2019advanced].

## Tracing errors

### Traceback

Let's consider the previously showed function example with a missing variable:

```{r, collapse=TRUE, error=TRUE}
# Ensure that z is missing
if (exists("z")) {
  rm(z)
}
g <- function(x) {
  return(x + z)
}

f <- function(x,y = g(x)) {
  if (x>0) {
    return(x)
  } else {
    return(y)
  }
}
f(-1)
```
This example is available here: [missing-variables.R](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/examples/missing-variables.R).

Opening the file with Rstudio and sourcing the file will return the following kind of an error:

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables.png)

Now clicking the **Show traceback**-button will expand the traceback:

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables-traceback.png)

This view will quickly show that the error comes from the `g(x)`-function call in line #13. 

Sometimes lazy evaluation can make reading the call stack complicated. Here we have few additional functions that are called in the argument definition:

```{r, collapse=TRUE, error=TRUE}
i <- function() {
  return(z)
}
h <- function() {
  return(i())
}
f(x=-1, y=h())
```

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables-lazy-evaluation.png)

Error is raised by `i()`, but looking at the call stack it almost looks like `f()` is somehow involved. This is because value of `h()` is evaluated only when it is needed in `f()`. Writing the code like this would reveal the true culprit:
```{r, collapse=TRUE, error=TRUE}
h_value=h()
f(x=-1, y=h_value)
```

Of course, this is not something you want to do generally. Lazy evaluation is good for speeding up your code, so doing changes like this should be limited to situations where you're unsure which function causes the error.

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables-nonlazy-evaluation.png)


### Traceback outside of Rstudio editor

If you run the code in R console in Rstudio or in a separate interpreter you might not get the **Show Traceback**-prompt.
In those situations you can use the `traceback()`-function to get the trace. You can try it out with the following test in the console:
```{r, eval=FALSE}
f(-1)
traceback()
```
You can also set the R error handling to call traceback on errors:
```{r, eval=FALSE}
backup_options <- options()
options(error=traceback)
f(-1)
options(backup_options)
```
Here we also took a backup of the default options. This is usually a good idea as changing options will change the options for the whole R session. 

## Interactive debugger

### Using Rstudio's "Rerun with Debug"

Rstudio can launch you a debugger at the location where the error occured. If you source the file again and launch the debugger with **Rerun with Debug**, you'll get an interactive debugger that looks something like this:

![](https://raw.githubusercontent.com/AaltoSciComp/r-debugging/main/images/missing-variables-run-with-debug.png)

This view has many areas of interest:
- On the top left Rstudio will open the source code of the problematic function
  and it tries to highlight the line that causes the error.
- On the top right we have an environment browser that shows what variables are defined inside
  the `g()`-function's environment.
- On the bottom right we have the traceback of the erroneous function call.
  The function we're investigating is highlighted.
- On the bottom left we have the interactive debugger open in the console.



### `debug` and `debugonce`

You can also launch debugger from the console with `debug`- and `debugonce`-functions.

`debug(f)` will set a permanent flag that will cause a debugger to be launched whenever
function `f` is called. You can unset this variable with `undebug`.

Alternatively, you can use `debugonce` to launch the debugger once in a function. This is
especially useful if the function you want to debug is inside a for-loop.

```{r, eval=FALSE}
debugonce(g)
f(-1)
```


## Quick debugging with environment browser

Finding the function that causes the error is one thing, but examining what caused is another. For quick debugging we can use the environment browser.

One can launch the interactive browser by specifying `browser()` is the code:
```{r, eval=FALSE}
g_browse <- function(x) {
  browser()
  return(x + z)
}
f(-1, y=g_browse(x))
```

